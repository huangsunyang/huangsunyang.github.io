<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="什么是内存管理内存是数据存储的介质，其访问速度比硬盘快，但是容量相对更小，且断电后数据会丢失。由于内存的种种性质，其成为了计算机开机后访问数据的最佳位置，操作系统或者用户进程所访问的数据大都也都是在内存上。 内存管理实际上管理的是内存物理介质的状态。内存作为一种物理介质，每一个bit都是0/1两种状态，它并不清楚自身存储的数据含义，甚至也并不清楚自身是否被使用了。 通常来说，操作系统为我们管理了作">
<meta name="keywords" content="python,源码,内存管理">
<meta property="og:type" content="article">
<meta property="og:title" content="CPython Memory Management">
<meta property="og:url" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/index.html">
<meta property="og:site_name" content="Decode">
<meta property="og:description" content="什么是内存管理内存是数据存储的介质，其访问速度比硬盘快，但是容量相对更小，且断电后数据会丢失。由于内存的种种性质，其成为了计算机开机后访问数据的最佳位置，操作系统或者用户进程所访问的数据大都也都是在内存上。 内存管理实际上管理的是内存物理介质的状态。内存作为一种物理介质，每一个bit都是0/1两种状态，它并不清楚自身存储的数据含义，甚至也并不清楚自身是否被使用了。 通常来说，操作系统为我们管理了作">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/overview.svg">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/pool.svg">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/graph-pool_mid_state.svg">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/graph-pool_mid_state_alloc.svg">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/graph-pool_mid_state_free.svg">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/graph-arena_align.svg">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/graph-arena_mid_state.svg">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/graph-new_arena.svg">
<meta property="og:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/graph-usedpools.svg">
<meta property="og:updated_time" content="2020-04-26T12:52:41.258Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CPython Memory Management">
<meta name="twitter:description" content="什么是内存管理内存是数据存储的介质，其访问速度比硬盘快，但是容量相对更小，且断电后数据会丢失。由于内存的种种性质，其成为了计算机开机后访问数据的最佳位置，操作系统或者用户进程所访问的数据大都也都是在内存上。 内存管理实际上管理的是内存物理介质的状态。内存作为一种物理介质，每一个bit都是0/1两种状态，它并不清楚自身存储的数据含义，甚至也并不清楚自身是否被使用了。 通常来说，操作系统为我们管理了作">
<meta name="twitter:image" content="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/overview.svg">
  <link rel="canonical" href="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>CPython Memory Management | Decode</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Decode</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">programming blog by huangsunyang</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huangsunyang.com/2020/04/25/cpython-memory-management/cpython-memory-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="_huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/portrait.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Decode">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">CPython Memory Management

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-04-25 17:24:23" itemprop="dateCreated datePublished" datetime="2020-04-25T17:24:23+08:00">2020-04-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-26 20:52:41" itemprop="dateModified" datetime="2020-04-26T20:52:41+08:00">2020-04-26</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python源码/" itemprop="url" rel="index"><span itemprop="name">python源码</span></a></span>

                
                
              
            </span>
          

          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>23k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>1:55</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="什么是内存管理"><a href="#什么是内存管理" class="headerlink" title="什么是内存管理"></a>什么是内存管理</h2><p>内存是数据存储的介质，其访问速度比硬盘快，但是容量相对更小，且断电后数据会丢失。由于内存的种种性质，其成为了计算机开机后访问数据的最佳位置，操作系统或者用户进程所访问的数据大都也都是在内存上。</p>
<p>内存管理实际上管理的是内存物理介质的状态。内存作为一种物理介质，每一个bit都是0/1两种状态，它并不清楚自身存储的数据含义，甚至也并不清楚自身是否被使用了。</p>
<p>通常来说，操作系统为我们管理了作为物理介质的内存，即使用虚拟内存和分页的方式，使得我们的用户进程能够访问连续的/不受物理内存大小限制的虚拟地址空间。其次，c运行库中的<code>malloc</code>/<code>calloc</code>函数在操作系统层面之上提供了堆空间内存分配的接口。而python在此基础之上，为所有<code>PyObject</code>提供了统一的内存分配/管理接口。</p>
<h2 id="为什么要进行内存管理"><a href="#为什么要进行内存管理" class="headerlink" title="为什么要进行内存管理"></a>为什么要进行内存管理</h2><p>个人认为，主要原因是为了减少内存分配调用而产生的开销；此外，通用的内存管理也方便在此基础上进行垃圾回收等其他操作。当调用<code>malloc</code>函数时，我们通常会陷入内核进行系统调用，甚至会产生缺页异常从而分配新的页并更新页表，这样的操作是相对费时的。python内存管理的核心目的就是减少小对象的内存分配次数，从而提高程序运行性能。</p>
<a id="more"></a>
<h2 id="Block-Pool-Arena概述"><a href="#Block-Pool-Arena概述" class="headerlink" title="Block/Pool/Arena概述"></a>Block/Pool/Arena概述</h2><p>python的内存管理中有三个重要概念，从小到大也就是<code>block</code>/<code>pool</code>/<code>arena</code></p>
<ul>
<li><code>block</code>对应着一个<code>PyObject</code>所占据的内存空间，小<code>PyObject</code>都会被分配在一个block中，可能会有一定的内部碎片，相当于字节对齐后的缝隙。block的大小从8-512字节不等。</li>
<li><code>pool</code>相当于对操作系统页的抽象，也是python内存管理通过<code>malloc</code>向操作系统申请内存的最小单位。每个<code>pool</code>都是4096字节，也就是4KB，对应大多数操作系统一页的大小。每个pool中包含的block都是固定大小的。</li>
<li><code>arena</code>主要用来管理<code>pool</code>，每个<code>arena</code>包含的内存空间大小固定为256KB，其中固定包含64个<code>pool</code>，且其中包含的<code>pool</code>并不一定都有相同的<code>block_size</code></li>
</ul>
<p><img src="overview.svg" alt="overview"></p>
<h2 id="pool如何管理block"><a href="#pool如何管理block" class="headerlink" title="pool如何管理block"></a>pool如何管理block</h2><h3 id="pool-header以及pool的初始化"><a href="#pool-header以及pool的初始化" class="headerlink" title="pool_header以及pool的初始化"></a>pool_header以及pool的初始化</h3><p>在<code>obmalloc.c</code>中的头部位置，python定义了<code>block</code>的字节对齐<code>ALIGNMENT</code>以及小对象的最大大小<code>SMALL_REQUEST_THRESHOLD</code>，实际上这也就是一个<code>block</code>的大小范围。同时，python也简单将<code>POOL_SIZE</code>定义为了大多数操作系统一页的大小4KB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Alignment of addresses returned to the user. 8-bytes alignment works</span></span><br><span class="line"><span class="comment"> * on most current architectures (with 32-bit or 64-bit address busses).</span></span><br><span class="line"><span class="comment"> * The alignment value is also used for grouping small requests in size</span></span><br><span class="line"><span class="comment"> * classes spaced ALIGNMENT bytes apart.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You shouldn't change this unless you know what you are doing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_VOID_P &gt; 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT              16               <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT_SHIFT         4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT               8               <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT_SHIFT         3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the number of bytes in size class I, as a uint. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDEX2SIZE(I) (((uint)(I) + 1) &lt;&lt; ALIGNMENT_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Max size threshold below which malloc requests are considered to be</span></span><br><span class="line"><span class="comment"> * small enough in order to use preallocated memory pools. You can tune</span></span><br><span class="line"><span class="comment"> * this value according to your application behaviour and memory needs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following invariants must hold:</span></span><br><span class="line"><span class="comment"> *      1) ALIGNMENT &lt;= SMALL_REQUEST_THRESHOLD &lt;= 512</span></span><br><span class="line"><span class="comment"> *      2) SMALL_REQUEST_THRESHOLD is evenly divisible by ALIGNMENT</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: a size threshold of 512 guarantees that newly created dictionaries</span></span><br><span class="line"><span class="comment"> * will be allocated from preallocated memory pools on 64-bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Although not required, for better performance and space efficiency,</span></span><br><span class="line"><span class="comment"> * it is recommended that SMALL_REQUEST_THRESHOLD is set to a power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALL_REQUEST_THRESHOLD 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NB_SMALL_SIZE_CLASSES   (SMALL_REQUEST_THRESHOLD / ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The system's VMM page size can be obtained on most unices with a</span></span><br><span class="line"><span class="comment"> * getpagesize() call or deduced from various header files. To make</span></span><br><span class="line"><span class="comment"> * things simpler, we assume that it is 4K, which is OK for most systems.</span></span><br><span class="line"><span class="comment"> * It is probably better if this is the native page size, but it doesn't</span></span><br><span class="line"><span class="comment"> * have to be.  In theory, if SYSTEM_PAGE_SIZE is larger than the native page</span></span><br><span class="line"><span class="comment"> * size, then `POOL_ADDR(p)-&gt;arenaindex' could rarely cause a segmentation</span></span><br><span class="line"><span class="comment"> * violation fault.  4K is apparently OK for all the platforms that python</span></span><br><span class="line"><span class="comment"> * currently targets.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PAGE_SIZE        (4 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PAGE_SIZE_MASK   (SYSTEM_PAGE_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Size of the pools used for small blocks. Should be a power of 2,</span></span><br><span class="line"><span class="comment"> * between 1K and SYSTEM_PAGE_SIZE, that is: 1k, 2k, 4k.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE               SYSTEM_PAGE_SIZE        <span class="comment">/* must be 2^N */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE_MASK          SYSTEM_PAGE_SIZE_MASK</span></span><br></pre></td></tr></table></figure>
<p>之后，python给出了<code>pool_header</code>的结构体定义，很容易看出多个<code>pool_header</code>都被串联在一个双向链表中。其中需要解释的字段也就是<code>free_block</code>，<code>nextoffset</code>和<code>maxnextoffset</code>，我们可以通过<code>init_pool</code>部分的相关代码来理解这几个变量。由于整个pool的内存分配是由<code>arena_object</code>管理的，因此这里pool的初始化里看不到这一方面的相关代码，就像<code>__init__</code>代码里是没有对象的内存分配代码一样。</p>
<p>这里我们会发现<code>pool</code>首先会被加入到<code>usedpools[size + size]</code>这个双向链表中，实际上<code>usedpools</code>可以理解为所有<code>pools</code>的一个切片，或者说一个<code>view</code>。能够通过<code>usedpools[size + size]</code>从中获取到所有<code>sizeidx</code>相同的可用的<code>pools</code>的双向链表。暂时可以不用管他。此外，中间有一段复用<code>pool</code>的代码，也可以先略过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pool for small blocks. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123; block *_padding;</span><br><span class="line">            uint count; &#125; ref;          <span class="comment">/* number of allocated blocks    */</span></span><br><span class="line">    block *freeblock;                   <span class="comment">/* pool's free list head         */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">nextpool</span>;</span>       <span class="comment">/* next pool of this size class  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">prevpool</span>;</span>       <span class="comment">/* previous pool       ""        */</span></span><br><span class="line">    uint arenaindex;                    <span class="comment">/* index into arenas of base adr */</span></span><br><span class="line">    uint szidx;                         <span class="comment">/* block size class index        */</span></span><br><span class="line">    uint nextoffset;                    <span class="comment">/* bytes to virgin block         */</span></span><br><span class="line">    uint maxnextoffset;                 <span class="comment">/* largest valid nextoffset      */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span> *<span class="title">poolp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* code fragment for init a pool in function pymalloc_alloc */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_OVERHEAD   _Py_SIZE_ROUND_UP(sizeof(struct pool_header), ALIGNMENT)</span></span><br><span class="line"></span><br><span class="line">init_pool:</span><br><span class="line">   <span class="comment">/* Frontlink to used pools. */</span></span><br><span class="line">   next = usedpools[size + size]; <span class="comment">/* == prev */</span></span><br><span class="line">   pool-&gt;nextpool = next;</span><br><span class="line">   pool-&gt;prevpool = next;</span><br><span class="line">   next-&gt;nextpool = pool;</span><br><span class="line">   next-&gt;prevpool = pool;</span><br><span class="line">   pool-&gt;ref.count = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (pool-&gt;szidx == size) &#123;</span><br><span class="line">      <span class="comment">/* Luckily, this pool last contained blocks</span></span><br><span class="line"><span class="comment">      * of the same size class, so its header</span></span><br><span class="line"><span class="comment">      * and free list are already initialized.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      bp = pool-&gt;freeblock;</span><br><span class="line">      assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">      pool-&gt;freeblock = *(block **)bp;</span><br><span class="line">      <span class="keyword">goto</span> success;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Initialize the pool header, set up the free list to</span></span><br><span class="line"><span class="comment">   * contain just the second block, and return the first</span></span><br><span class="line"><span class="comment">   * block.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   pool-&gt;szidx = size;</span><br><span class="line">   size = INDEX2SIZE(size);</span><br><span class="line">   bp = (block *)pool + POOL_OVERHEAD;</span><br><span class="line">   pool-&gt;nextoffset = POOL_OVERHEAD + (size &lt;&lt; <span class="number">1</span>);</span><br><span class="line">   pool-&gt;maxnextoffset = POOL_SIZE - size;</span><br><span class="line">   pool-&gt;freeblock = bp + size;</span><br><span class="line">   *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">goto</span> success;</span><br></pre></td></tr></table></figure>
<p>下图展示了一块刚被初始化的<code>pool</code>的状态，此时所有的<code>block</code>都未被分配，<code>freeblock</code>指向了第一块<code>block</code>，<code>nextoffset</code>指向了第二块，<code>maxnextoffset</code>指向了最后一块。除此之外，<code>freeblock</code>所指向的内存的第一个指针大小空间被置为了<code>NULL</code>。</p>
<p><img src="pool.svg" alt="pool"></p>
<h3 id="pool如何分配block"><a href="#pool如何分配block" class="headerlink" title="pool如何分配block"></a>pool如何分配block</h3><p>从如下代码分析，<code>usedpools</code>中存放的都是还未放满的pool，因为必定有一个<code>freeblock</code>。所以在这个分支下，分配的内存空间地址肯定就是<code>pool-&gt;freeblock</code>了。但是取走当前<code>freeblock</code>之后还需要找到下一个<code>freeblock</code>，还记得之前初始化时，<code>freeblock</code>位置处放置了一个NULL指针，这实际上时<code>freeblock</code>链表结束的标志。在其他情况下，该位置处存放的指针也就是下一个<code>freeblock</code>的地址。由此得出维护状态的两种情况：</p>
<ul>
<li><p>存在下一个<code>freeblock</code>，将<code>freeblock</code>赋值为下一个指针即可</p>
</li>
<li><p>没有下一个<code>freeblock</code>，即<code>freeblock</code>指向的地址处是NULL指针</p>
<ul>
<li>尝试将<code>nextoffset</code>处的地址作为<code>freeblock</code></li>
<li><code>nextoffset</code>也走到头了，即<code>nextoffset</code>走到了<code>maxnextoffset</code>位置<ul>
<li>说明<code>pool</code>已满，将这个<code>pool</code>从<code>usedpool[size + size]</code>双向链表中移除</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* code fragment for allocate a block in function pymalloc_alloc */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Most frequent paths first</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">pool = usedpools[size + size];</span><br><span class="line"><span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * There is a used pool for this size class.</span></span><br><span class="line"><span class="comment">    * Pick up the head block of its free list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ++pool-&gt;ref.count;</span><br><span class="line">    bp = pool-&gt;freeblock;</span><br><span class="line">    assert(bp != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ((pool-&gt;freeblock = *(block **)bp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Reached the end of the free list, try to extend it.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;nextoffset &lt;= pool-&gt;maxnextoffset) &#123;</span><br><span class="line">        <span class="comment">/* There is room for another block. */</span></span><br><span class="line">        pool-&gt;freeblock = (block*)pool +</span><br><span class="line">            pool-&gt;nextoffset;</span><br><span class="line">        pool-&gt;nextoffset += INDEX2SIZE(size);</span><br><span class="line">        *(block **)(pool-&gt;freeblock) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Pool is full, unlink from used pools. */</span></span><br><span class="line">    next = pool-&gt;nextpool;</span><br><span class="line">    pool = pool-&gt;prevpool;</span><br><span class="line">    next-&gt;prevpool = pool;</span><br><span class="line">    pool-&gt;nextpool = next;</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pool如何释放block"><a href="#pool如何释放block" class="headerlink" title="pool如何释放block"></a>pool如何释放block</h3><p>释放block和分配的过程非常相似，实际上也就是分配的逆操作。其大致流程如下：</p>
<ul>
<li>如果当前<code>pool</code>的<code>freeblock</code>不为<code>NULL</code>，及说明当前<code>pool</code>还有<code>freeblock</code><ul>
<li>将这个释放的<code>block</code>链接到<code>freeblock</code>链表的头部</li>
</ul>
</li>
<li>如果当前pool的<code>freeblock</code>为<code>NULL</code>，说明pool已满，也就不在<code>usedpools</code>链表中<ul>
<li>这时需要将<code>pool</code>重新链接回<code>usedpools</code>链表中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* code fragment for free a block in function pymalloc_free */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Link p to the start of the pool's freeblock list.  Since</span></span><br><span class="line"><span class="comment">* the pool had at least the p block outstanding, the pool</span></span><br><span class="line"><span class="comment">* wasn't empty (so it's already in a usedpools[] list, or</span></span><br><span class="line"><span class="comment">* was full and is in no list -- it's not in the freeblocks</span></span><br><span class="line"><span class="comment">* list in any case).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assert(pool-&gt;ref.count &gt; <span class="number">0</span>);            <span class="comment">/* else it was empty */</span></span><br><span class="line">*(block **)p = lastfree = pool-&gt;freeblock;</span><br><span class="line">pool-&gt;freeblock = (block *)p;</span><br><span class="line"><span class="keyword">if</span> (!lastfree) &#123;</span><br><span class="line">    <span class="comment">/* Pool was full, so doesn't currently live in any list:</span></span><br><span class="line"><span class="comment">    * link it to the front of the appropriate usedpools[] list.</span></span><br><span class="line"><span class="comment">    * This mimics LRU pool usage for new allocations and</span></span><br><span class="line"><span class="comment">    * targets optimal filling when several pools contain</span></span><br><span class="line"><span class="comment">    * blocks of the same size class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    --pool-&gt;ref.count;</span><br><span class="line">    assert(pool-&gt;ref.count &gt; <span class="number">0</span>);            <span class="comment">/* else the pool is empty */</span></span><br><span class="line">    size = pool-&gt;szidx;</span><br><span class="line">    next = usedpools[size + size];</span><br><span class="line">    prev = next-&gt;prevpool;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* insert pool before next:   prev &lt;-&gt; pool &lt;-&gt; next */</span></span><br><span class="line">    pool-&gt;nextpool = next;</span><br><span class="line">    pool-&gt;prevpool = prev;</span><br><span class="line">    next-&gt;prevpool = pool;</span><br><span class="line">    prev-&gt;nextpool = pool;</span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* freeblock wasn't NULL, so the pool wasn't full,</span></span><br><span class="line"><span class="comment"> * and the pool is in a usedpools[] list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (--pool-&gt;ref.count != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* pool isn't empty:  leave it in usedpools */</span></span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pool分配释放block图示"><a href="#pool分配释放block图示" class="headerlink" title="pool分配释放block图示"></a>pool分配释放block图示</h3><p>pool的一个中间状态可能如下图所示：</p>
<p><img src="graph-pool_mid_state.svg" alt="graph-pool_mid_state"></p>
<p>此时如果分配了一个block，则会变为如下图所示</p>
<p><img src="graph-pool_mid_state_alloc.svg" alt="graph-pool_mid_state_alloc"></p>
<p>此后如果又释放了一个block，则会变为如下图所示</p>
<p><img src="graph-pool_mid_state_free.svg" alt="graph-pool_mid_state_free"></p>
<h2 id="arena-object如何管理pool"><a href="#arena-object如何管理pool" class="headerlink" title="arena_object如何管理pool"></a>arena_object如何管理pool</h2><h3 id="arena-object结构体"><a href="#arena-object结构体" class="headerlink" title="arena_object结构体"></a>arena_object结构体</h3><p><code>arena_object</code>结构体的定义如下，注意到和<code>pool</code>不同的是，<code>arena_object</code>持有的空间并不包括其自身，而是用<code>address</code>指向的，此外，<code>pool</code>所在的地址是经过字节对齐的，因而是不是从<code>address</code>开始累加的。</p>
<p>此外，关于<code>arena</code>还定义了一部分常量，例如</p>
<ul>
<li>一个<code>arena</code>是256KB</li>
<li>第一次分配的<code>arena</code>的数量为16</li>
<li>一个<code>arena</code>最多包含的<code>pool</code>数量为64</li>
</ul>
<p>需要注意的是，<code>arena_object</code>只负责提供一个空的<code>pool</code>，至于这一个<code>pool</code>中的<code>block</code>被使用了一个还是全部，<code>arena_object</code>是不负责管理的。也就是说，只有<code>pool</code>从空到非空状态，或者从非空到空状态，才会触发<code>arena_object</code>的管理操作。</p>
<p>再次强调，<code>arena_object</code>只负责提供一个空的<code>pool</code>，记住这个中心原则对理解代码很有帮助。</p>
<p><img src="graph-arena_align.svg" alt="graph-arena_align"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record keeping for arenas. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The address of the arena, as returned by malloc.  Note that 0</span></span><br><span class="line"><span class="comment">     * will never be returned by a successful malloc, and is used</span></span><br><span class="line"><span class="comment">     * here to mark an arena_object that doesn't correspond to an</span></span><br><span class="line"><span class="comment">     * allocated arena.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pool-aligned pointer to the next pool to be carved off. */</span></span><br><span class="line">    block* pool_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The number of available pools in the arena:  free pools + never-</span></span><br><span class="line"><span class="comment">     * allocated pools.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    uint nfreepools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The total number of pools in the arena, whether or not available. */</span></span><br><span class="line">    uint ntotalpools;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Singly-linked list of available pools. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_header</span>* <span class="title">freepools</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Whenever this arena_object is not associated with an allocated</span></span><br><span class="line"><span class="comment">     * arena, the nextarena member is used to link all unassociated</span></span><br><span class="line"><span class="comment">     * arena_objects in the singly-linked `unused_arena_objects` list.</span></span><br><span class="line"><span class="comment">     * The prevarena member is unused in this case.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When this arena_object is associated with an allocated arena</span></span><br><span class="line"><span class="comment">     * with at least one available pool, both members are used in the</span></span><br><span class="line"><span class="comment">     * doubly-linked `usable_arenas` list, which is maintained in</span></span><br><span class="line"><span class="comment">     * increasing order of `nfreepools` values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Else this arena_object is associated with an allocated arena</span></span><br><span class="line"><span class="comment">     * all of whose pools are in use.  `nextarena` and `prevarena`</span></span><br><span class="line"><span class="comment">     * are both meaningless in this case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nextarena</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">prevarena</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The allocator sub-allocates &lt;Big&gt; blocks of memory (called arenas) aligned</span></span><br><span class="line"><span class="comment"> * on a page boundary. This is a reserved virtual address space for the</span></span><br><span class="line"><span class="comment"> * current process (obtained through a malloc()/mmap() call). In no way this</span></span><br><span class="line"><span class="comment"> * means that the memory arenas will be used entirely. A malloc(&lt;Big&gt;) is</span></span><br><span class="line"><span class="comment"> * usually an address range reservation for &lt;Big&gt; bytes, unless all pages within</span></span><br><span class="line"><span class="comment"> * this space are referenced subsequently. So malloc'ing big blocks and not</span></span><br><span class="line"><span class="comment"> * using them does not mean "wasting memory". It's an addressable range</span></span><br><span class="line"><span class="comment"> * wastage...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Arenas are allocated with mmap() on systems supporting anonymous memory</span></span><br><span class="line"><span class="comment"> * mappings to reduce heap fragmentation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_SIZE              (256 &lt;&lt; 10)     <span class="comment">/* 256KB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_POOLS_IN_ARENA  (ARENA_SIZE / POOL_SIZE)</span></span><br></pre></td></tr></table></figure>
<h3 id="arena-object的初始化"><a href="#arena-object的初始化" class="headerlink" title="arena_object的初始化"></a>arena_object的初始化</h3><p>arena_object的初始化也和pool_header初始化基本一致，先是分配了整个arena的空间在address，在计算字节对齐后将pool_address初始化。初始化后的arena_object如图所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take the next available arena object off the head of the list. */</span></span><br><span class="line">arenaobj = unused_arena_objects;</span><br><span class="line">unused_arena_objects = arenaobj-&gt;nextarena;</span><br><span class="line">address = _PyObject_Arena.alloc(_PyObject_Arena.ctx, ARENA_SIZE);</span><br><span class="line"><span class="keyword">if</span> (address == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* The allocation failed: return NULL after putting the</span></span><br><span class="line"><span class="comment">     * arenaobj back.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    arenaobj-&gt;nextarena = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = arenaobj;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">arenaobj-&gt;address = (<span class="keyword">uintptr_t</span>)address;</span><br><span class="line"></span><br><span class="line">arenaobj-&gt;freepools = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* pool_address &lt;- first pool-aligned address in the arena</span></span><br><span class="line"><span class="comment">   nfreepools &lt;- number of whole pools that fit after alignment */</span></span><br><span class="line">arenaobj-&gt;pool_address = (block*)arenaobj-&gt;address;</span><br><span class="line">arenaobj-&gt;nfreepools = MAX_POOLS_IN_ARENA;</span><br><span class="line">excess = (uint)(arenaobj-&gt;address &amp; POOL_SIZE_MASK);</span><br><span class="line"><span class="keyword">if</span> (excess != <span class="number">0</span>) &#123;</span><br><span class="line">    --arenaobj-&gt;nfreepools;</span><br><span class="line">    arenaobj-&gt;pool_address += POOL_SIZE - excess;</span><br><span class="line">&#125;</span><br><span class="line">arenaobj-&gt;ntotalpools = arenaobj-&gt;nfreepools;</span><br></pre></td></tr></table></figure>
<h3 id="arena如何分配pool"><a href="#arena如何分配pool" class="headerlink" title="arena如何分配pool"></a>arena如何分配pool</h3><p>和<code>pool</code>分配<code>block</code>非常类似</p>
<ul>
<li><code>arena_object</code>中的<code>freepools</code>就相当于<code>pool_header</code>中的<code>freeblock</code></li>
<li><code>arena_object</code>中的<code>pool_address</code>就相当于<code>pool_header</code>中的<code>nextoffset</code></li>
<li><code>arena_object</code>中没有<code>maxnextoffset</code>，因为<code>maxnextoffset</code>可以用<code>address + ARENA_SIZE - POOL_SIZE</code>计算得到</li>
</ul>
<p>由此我们很容易理解arena分配pool的流程</p>
<ul>
<li><p>如果<code>freepools</code>中有可用的pool，则从<code>freepools</code>中取出一个可用的pool，并更新<code>freepools</code>链表</p>
</li>
<li><p>如果<code>freepools</code>为空，则从<code>pool_address</code>处取出一块<code>POOL_SIZE</code>大小的空间作为<code>pool</code></p>
</li>
</ul>
<p>和<code>pool</code>分配<code>block</code>相比，还是有些许的不同，<code>pool_header</code>中单用<code>freeblock</code>指针即可判断pool中是否还有<code>freeblock</code>，因为每次<code>pool_header</code>是在分配后保证<code>freeblock</code>指向一块空闲空间。而<code>arena_object</code>则没有这样的处理，因此会有两次判断，也有一些重复代码（将<code>arena</code>从<code>usable_arenas</code>链表中删除的代码），因为最后一块空闲的<code>pool</code>可能在<code>address</code>处也可能在<code>freepools</code>处。相比之下，<code>pool_header</code>的方法虽然稍微多了一些理解成本，但是实现上更巧妙。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try to get a cached free pool. */</span></span><br><span class="line">pool = usable_arenas-&gt;freepools;</span><br><span class="line"><span class="keyword">if</span> (pool != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Unlink from cached pools. */</span></span><br><span class="line">    usable_arenas-&gt;freepools = pool-&gt;nextpool;</span><br><span class="line">    --usable_arenas-&gt;nfreepools;</span><br><span class="line">    <span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Wholly allocated:  remove. */</span></span><br><span class="line">        usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">        <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">init_pool:</span><br><span class="line">    <span class="comment">/* omit pool init code */</span></span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Carve off a new pool. */</span></span><br><span class="line">pool = (poolp)usable_arenas-&gt;pool_address;</span><br><span class="line">pool-&gt;arenaindex = (uint)(usable_arenas - arenas);</span><br><span class="line">pool-&gt;szidx = DUMMY_SIZE_IDX;</span><br><span class="line">usable_arenas-&gt;pool_address += POOL_SIZE;</span><br><span class="line">--usable_arenas-&gt;nfreepools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usable_arenas-&gt;nfreepools == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Unlink the arena:  it is completely allocated. */</span></span><br><span class="line">    usable_arenas = usable_arenas-&gt;nextarena;</span><br><span class="line">    <span class="keyword">if</span> (usable_arenas != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> init_pool;</span><br></pre></td></tr></table></figure>
<h3 id="arena如何释放pool"><a href="#arena如何释放pool" class="headerlink" title="arena如何释放pool"></a>arena如何释放pool</h3><p>当释放完一个<code>block</code>，当前pool为空时，即<code>pool-&gt;ref.count</code>为0，则会触发<code>arena</code>回收<code>pool</code>的操作，和<code>pool</code>回收<code>block</code>一样，只是简单地将其放回<code>freepools</code>中即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">ao</span>;</span></span><br><span class="line">uint nf;  <span class="comment">/* ao-&gt;nfreepools */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* freeblock wasn't NULL, so the pool wasn't full,</span></span><br><span class="line"><span class="comment"> * and the pool is in a usedpools[] list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (--pool-&gt;ref.count != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* pool isn't empty:  leave it in usedpools */</span></span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Pool is now empty:  unlink from usedpools, and</span></span><br><span class="line"><span class="comment"> * link to the front of freepools.  This ensures that</span></span><br><span class="line"><span class="comment"> * previously freed pools will be allocated later</span></span><br><span class="line"><span class="comment"> * (being not referenced, they are perhaps paged out).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">next = pool-&gt;nextpool;</span><br><span class="line">prev = pool-&gt;prevpool;</span><br><span class="line">next-&gt;prevpool = prev;</span><br><span class="line">prev-&gt;nextpool = next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Link the pool to freepools.  This is a singly-linked</span></span><br><span class="line"><span class="comment"> * list, and pool-&gt;prevpool isn't used there.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ao = &amp;arenas[pool-&gt;arenaindex];</span><br><span class="line">pool-&gt;nextpool = ao-&gt;freepools;</span><br><span class="line">ao-&gt;freepools = pool;</span><br><span class="line">++ao-&gt;nfreepools;</span><br></pre></td></tr></table></figure>
<h2 id="如何管理arena-object"><a href="#如何管理arena-object" class="headerlink" title="如何管理arena_object"></a>如何管理arena_object</h2><h3 id="arena-object所在的容器"><a href="#arena-object所在的容器" class="headerlink" title="arena_object所在的容器"></a>arena_object所在的容器</h3><p><code>arena_object</code>主要通过一个数组和两个链表进行管理：</p>
<ul>
<li><code>arenas</code>中存放了所有arena的数组，类似动态数组，翻倍增长</li>
<li><code>usable_arenas</code>是存放了所有使用了的，即<code>nfreepools</code>大于0小于<code>ntotalpools</code>的<code>arena_object</code>的双向链表</li>
<li><code>unused_arena_objects</code>存放所有未使用的，即<code>nfreepools</code>为<code>ntotalpools</code>的<code>arena_object</code>的单向链表</li>
<li>而所有<code>pool</code>都已经使用的，即<code>nfreepools</code>为0的<code>arena_object</code>，则只放在<code>arenas</code>中，没有链表管理</li>
</ul>
<p><code>arenas</code>数组中一种可能的状态如图所示：</p>
<p><img src="graph-arena_mid_state.svg" alt="graph-pool_mid_state_alloc"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Array of objects used to track chunks of memory (arenas). */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenas</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="comment">/* Number of slots currently allocated in the `arenas` vector. */</span></span><br><span class="line"><span class="keyword">static</span> uint maxarenas = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The head of the singly-linked, NULL-terminated list of available</span></span><br><span class="line"><span class="comment"> * arena_objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">unused_arena_objects</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The head of the doubly-linked, NULL-terminated at each end, list of</span></span><br><span class="line"><span class="comment"> * arena_objects associated with arenas that have pools available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">usable_arenas</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* nfp2lasta[nfp] is the last arena in usable_arenas with nfp free pools */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">nfp2lasta</span>[<span class="title">MAX_POOLS_IN_ARENA</span> + 1] = &#123;</span> <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* How many arena_objects do we initially allocate?</span></span><br><span class="line"><span class="comment"> * 16 = can allocate 16 arenas = 16 * ARENA_SIZE = 4MB before growing the</span></span><br><span class="line"><span class="comment"> * `arenas` vector.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIAL_ARENA_OBJECTS 16</span></span><br></pre></td></tr></table></figure>
<h3 id="arena-object的创建和分配"><a href="#arena-object的创建和分配" class="headerlink" title="arena_object的创建和分配"></a>arena_object的创建和分配</h3><p>什么时候会创建一个新的<code>arena_object</code>对象呢？试想一下，如果想要分配一定的内存空间，如果恰好有一个对应<code>szidx</code>的未满的<code>pool</code>，实际上也就足够了。如果没有这样的<code>pool</code>，如果有<code>arena_object</code>（即从<code>useable_arenas</code>中获取一个）能够提供一个空的<code>pool</code>改造一下，也能凑合用了。最坏情况是，所有对应<code>szidx</code>的<code>pool</code>都满了，而且也没有空的<code>pool</code>了，这时候只能重新创建新的<code>arena_object</code>了。相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">size = (uint)(nbytes - <span class="number">1</span>) &gt;&gt; ALIGNMENT_SHIFT;</span><br><span class="line">pool = usedpools[size + size];</span><br><span class="line"><span class="keyword">if</span> (pool != pool-&gt;nextpool) &#123;</span><br><span class="line">    <span class="comment">// ... omit code when you can get a pool with right szidx</span></span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* There isn't a pool of the right size class immediately</span></span><br><span class="line"><span class="comment"> * available:  use a free pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* No arena has a free pool:  allocate a new arena. */</span></span><br><span class="line">    usable_arenas = new_arena();</span><br><span class="line">    <span class="keyword">if</span> (usable_arenas == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    usable_arenas-&gt;nextarena =</span><br><span class="line">        usable_arenas-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">    assert(nfp2lasta[usable_arenas-&gt;nfreepools] == <span class="literal">NULL</span>);</span><br><span class="line">    nfp2lasta[usable_arenas-&gt;nfreepools] = usable_arenas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>arena_object</code>的创建主要经历以下几个流程：</p>
<ul>
<li><p>如果没有未使用的<code>arena_object</code>，即<code>unused_arena_objects</code>为<code>NULL</code></p>
<ul>
<li>创建两倍原大小的<code>arena_object</code>的数组，第一次则创建16个。之后将后一半<code>arena_object</code>连接到<code>unused_arena_objects</code>链表中去</li>
</ul>
</li>
<li>此时可以从<code>unused_arena_objects</code>中取出一个<code>arena</code>进行初始化操作<ul>
<li>从<code>unused_arena_objects</code>中移除</li>
<li>分配内存空间</li>
<li>处理<code>pool</code>字节对齐，初始化<code>pool</code>总数以及可用pool总数</li>
</ul>
</li>
</ul>
<p>对应于代码中的三个状态如下图所示：</p>
<p><img src="graph-new_arena.svg" alt="graph-new_arena"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate a new arena.  If we run out of memory, return NULL.  Else</span></span><br><span class="line"><span class="comment"> * allocate a new arena, and return the address of an arena_object</span></span><br><span class="line"><span class="comment"> * describing the new arena.  It's expected that the caller will set</span></span><br><span class="line"><span class="comment"> * `usable_arenas` to the return value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>*</span></span><br><span class="line"><span class="class"><span class="title">new_arena</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena_object</span>* <span class="title">arenaobj</span>;</span></span><br><span class="line">    uint excess;        <span class="comment">/* number of bytes above pool alignment */</span></span><br><span class="line">    <span class="keyword">void</span> *address;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (unused_arena_objects == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* state for picture 1 */</span></span><br><span class="line">        uint i;</span><br><span class="line">        uint numarenas;</span><br><span class="line">        <span class="keyword">size_t</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Double the number of arena objects on each allocation.*/</span></span><br><span class="line">        numarenas = maxarenas ? maxarenas &lt;&lt; <span class="number">1</span> : INITIAL_ARENA_OBJECTS;</span><br><span class="line"></span><br><span class="line">        nbytes = numarenas * <span class="keyword">sizeof</span>(*arenas);</span><br><span class="line">        arenaobj = (struct arena_object *)PyMem_RawRealloc(arenas, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (arenaobj == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        arenas = arenaobj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Put the new arenas on the unused_arena_objects list. */</span></span><br><span class="line">        <span class="keyword">for</span> (i = maxarenas; i &lt; numarenas; ++i) &#123;</span><br><span class="line">            arenas[i].address = <span class="number">0</span>;              <span class="comment">/* mark as unassociated */</span></span><br><span class="line">            arenas[i].nextarena = i &lt; numarenas - <span class="number">1</span> ?</span><br><span class="line">                                   &amp;arenas[i+<span class="number">1</span>] : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update globals. */</span></span><br><span class="line">        unused_arena_objects = &amp;arenas[maxarenas];</span><br><span class="line">        maxarenas = numarenas;</span><br><span class="line">        <span class="comment">/* state for picture 2 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omit init arena_object code */</span></span><br><span class="line">    <span class="comment">/* state for picture 3 */</span></span><br><span class="line">    <span class="keyword">return</span> arenaobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="arena-object的释放"><a href="#arena-object的释放" class="headerlink" title="arena_object的释放"></a>arena_object的释放</h3><p>释放一个<code>block</code>后，我们很可能会产生一连串的连锁反应，导致持有<code>block</code>的<code>pool</code>的状态变化。同样的，在释放一个<code>pool</code>后，也会使得持有这个<code>pool</code>的<code>arena_object</code>的状态产生变化，会有一下两种情况：</p>
<ol>
<li>释放的pool为<code>arena_object</code>中唯一使用的<code>pool</code>，那么需要将这个<code>arena_object</code>持有的内存释放，并将<code>arena_object</code>从<code>usable_arenas</code>链表中移除，并加入到<code>unused_arena_objects</code>链表中</li>
<li>释放的<code>pool</code>前<code>arena_object</code>是满的，那么需要将<code>arena_object</code>重新放到<code>usable_arenas</code>中</li>
<li>释放<code>pool</code>前后<code>arena_object</code>都在<code>usable_arenas</code>中，由于<code>usable_arenas</code>链表中是按照<code>nfreepools</code>从小到大排序的，因而需要维护一下顺序（此段代码未附）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nf == ao-&gt;ntotalpools) &#123;</span><br><span class="line">    <span class="comment">/* Case 1.  First unlink ao from usable_arenas.</span></span><br><span class="line"><span class="comment">     * Fix the pointer in the prevarena, or the</span></span><br><span class="line"><span class="comment">     * usable_arenas pointer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ao-&gt;prevarena == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        usable_arenas = ao-&gt;nextarena;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ao-&gt;prevarena-&gt;nextarena = ao-&gt;nextarena;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Fix the pointer in the nextarena. */</span></span><br><span class="line">    <span class="keyword">if</span> (ao-&gt;nextarena != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ao-&gt;nextarena-&gt;prevarena = ao-&gt;prevarena;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Record that this arena_object slot is</span></span><br><span class="line"><span class="comment">     * available to be reused.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ao-&gt;nextarena = unused_arena_objects;</span><br><span class="line">    unused_arena_objects = ao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the entire arena. */</span></span><br><span class="line">    _PyObject_Arena.<span class="built_in">free</span>(_PyObject_Arena.ctx,</span><br><span class="line">                         (<span class="keyword">void</span> *)ao-&gt;address, ARENA_SIZE);</span><br><span class="line">    ao-&gt;address = <span class="number">0</span>;                        <span class="comment">/* mark unassociated */</span></span><br><span class="line">    --narenas_currently_allocated;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nf == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* Case 2.  Put ao at the head of</span></span><br><span class="line"><span class="comment">     * usable_arenas.  Note that because</span></span><br><span class="line"><span class="comment">     * ao-&gt;nfreepools was 0 before, ao isn't</span></span><br><span class="line"><span class="comment">     * currently on the usable_arenas list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ao-&gt;nextarena = usable_arenas;</span><br><span class="line">    ao-&gt;prevarena = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (usable_arenas)</span><br><span class="line">        usable_arenas-&gt;prevarena = ao;</span><br><span class="line">    usable_arenas = ao;</span><br><span class="line">    <span class="keyword">if</span> (nfp2lasta[<span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        nfp2lasta[<span class="number">1</span>] = ao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="usedpools是什么"><a href="#usedpools是什么" class="headerlink" title="usedpools是什么"></a>usedpools是什么</h2><p><code>usedpools</code>实际上是用<code>pool</code>的<code>szidx</code>作为索引的双向链表。举例来说，<code>usedpools[i + i]</code>中存放的也就是<code>szidx=i</code>的不为空也不满的pools所在的双向链表。回顾一下前文，<code>arena_object</code>中只使用<code>freepools</code>管理了所有为空的<code>pool</code>，放满的<code>pool</code>以及部分使用的<code>pool</code>是未管理的，到了这一章节我们知道了部分使用的<code>pool</code>是通过<code>usedpools</code>来管理的，这是什么原因导致的呢？因为<code>szidx</code>相等的<code>pool</code>是跨<code>arena</code>连接的，因而无法在<code>arena_object</code>内部管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTA(x)  ((poolp )((uint8_t *)&amp;(usedpools[2*(x)]) - 2*sizeof(block *)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT(x)   PTA(x), PTA(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> poolp usedpools[<span class="number">2</span> * ((NB_SMALL_SIZE_CLASSES + <span class="number">7</span>) / <span class="number">8</span>) * <span class="number">8</span>] = &#123;</span><br><span class="line">    PT(<span class="number">0</span>), PT(<span class="number">1</span>), PT(<span class="number">2</span>), PT(<span class="number">3</span>), PT(<span class="number">4</span>), PT(<span class="number">5</span>), PT(<span class="number">6</span>), PT(<span class="number">7</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">8</span></span><br><span class="line">    , PT(<span class="number">8</span>), PT(<span class="number">9</span>), PT(<span class="number">10</span>), PT(<span class="number">11</span>), PT(<span class="number">12</span>), PT(<span class="number">13</span>), PT(<span class="number">14</span>), PT(<span class="number">15</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">16</span></span><br><span class="line">    , PT(<span class="number">16</span>), PT(<span class="number">17</span>), PT(<span class="number">18</span>), PT(<span class="number">19</span>), PT(<span class="number">20</span>), PT(<span class="number">21</span>), PT(<span class="number">22</span>), PT(<span class="number">23</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">24</span></span><br><span class="line">    , PT(<span class="number">24</span>), PT(<span class="number">25</span>), PT(<span class="number">26</span>), PT(<span class="number">27</span>), PT(<span class="number">28</span>), PT(<span class="number">29</span>), PT(<span class="number">30</span>), PT(<span class="number">31</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">32</span></span><br><span class="line">    , PT(<span class="number">32</span>), PT(<span class="number">33</span>), PT(<span class="number">34</span>), PT(<span class="number">35</span>), PT(<span class="number">36</span>), PT(<span class="number">37</span>), PT(<span class="number">38</span>), PT(<span class="number">39</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">40</span></span><br><span class="line">    , PT(<span class="number">40</span>), PT(<span class="number">41</span>), PT(<span class="number">42</span>), PT(<span class="number">43</span>), PT(<span class="number">44</span>), PT(<span class="number">45</span>), PT(<span class="number">46</span>), PT(<span class="number">47</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">48</span></span><br><span class="line">    , PT(<span class="number">48</span>), PT(<span class="number">49</span>), PT(<span class="number">50</span>), PT(<span class="number">51</span>), PT(<span class="number">52</span>), PT(<span class="number">53</span>), PT(<span class="number">54</span>), PT(<span class="number">55</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">56</span></span><br><span class="line">    , PT(<span class="number">56</span>), PT(<span class="number">57</span>), PT(<span class="number">58</span>), PT(<span class="number">59</span>), PT(<span class="number">60</span>), PT(<span class="number">61</span>), PT(<span class="number">62</span>), PT(<span class="number">63</span>)</span><br><span class="line">#<span class="keyword">if</span> NB_SMALL_SIZE_CLASSES &gt; <span class="number">64</span></span><br><span class="line">#error <span class="string">"NB_SMALL_SIZE_CLASSES should be less than 64"</span></span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 64 */</span></span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 56 */</span></span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 48 */</span></span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 40 */</span></span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 32 */</span></span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 24 */</span></span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt; 16 */</span></span><br><span class="line">#endif <span class="comment">/* NB_SMALL_SIZE_CLASSES &gt;  8 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="usedpools的巧妙结构"><a href="#usedpools的巧妙结构" class="headerlink" title="usedpools的巧妙结构"></a>usedpools的巧妙结构</h3><p>通常来说，巧妙和理解成本在一定程度上也是成正比的。按照一般思路，如果想要用<code>usedpools</code>中每一项都存放一个pool的双向链表的话，<code>usedpools</code>每一项都应该是一个<code>poolp</code>指针。如果要给每个双向链表一个虚拟的头结点，那就需要多分配整个pool_header的大小，但是实际我们只需要使用<code>nextpool</code>和<code>prevpool</code>这两个成员。</p>
<p>下图展示了<code>usedpools</code>刚刚初始化完成时的状态，<code>usedpool[i + i]</code>以及<code>usedpools[i + i + 1]</code>中都存放着<code>usedpools[i-1 + i-1]</code>的地址。但是这个地址被当作了pool_header，所以从这个地址作<code>.nextpool</code>操作和<code>.prevpool</code>操作都会取到自身，这也就是初始化的头结点的状态。</p>
<p>在添加<code>pool_header</code>结构体到链表后，<code>nextpool</code>和<code>prevpool</code>就会连接到一个真正的<code>pool_header</code>对象上了。</p>
<p><img src="graph-usedpools.svg" alt="graph-usedpools"></p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/python/" rel="tag"># python</a>
            
              <a href="/tags/源码/" rel="tag"># 源码</a>
            
              <a href="/tags/内存管理/" rel="tag"># 内存管理</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/04/21/cpython-super/" rel="next" title="CPython Super">
                  <i class="fa fa-chevron-left"></i> CPython Super
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/portrait.jpg"
      alt="_huang">
  <p class="site-author-name" itemprop="name">_huang</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/huangsunyang" title="GitHub &rarr; https://github.com/huangsunyang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:huangsunyang@126.com" title="E-Mail &rarr; mailto:huangsunyang@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是内存管理"><span class="nav-number">1.</span> <span class="nav-text">什么是内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要进行内存管理"><span class="nav-number">2.</span> <span class="nav-text">为什么要进行内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Block-Pool-Arena概述"><span class="nav-number">3.</span> <span class="nav-text">Block/Pool/Arena概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pool如何管理block"><span class="nav-number">4.</span> <span class="nav-text">pool如何管理block</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pool-header以及pool的初始化"><span class="nav-number">4.1.</span> <span class="nav-text">pool_header以及pool的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pool如何分配block"><span class="nav-number">4.2.</span> <span class="nav-text">pool如何分配block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pool如何释放block"><span class="nav-number">4.3.</span> <span class="nav-text">pool如何释放block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pool分配释放block图示"><span class="nav-number">4.4.</span> <span class="nav-text">pool分配释放block图示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arena-object如何管理pool"><span class="nav-number">5.</span> <span class="nav-text">arena_object如何管理pool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-object结构体"><span class="nav-number">5.1.</span> <span class="nav-text">arena_object结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-object的初始化"><span class="nav-number">5.2.</span> <span class="nav-text">arena_object的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena如何分配pool"><span class="nav-number">5.3.</span> <span class="nav-text">arena如何分配pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena如何释放pool"><span class="nav-number">5.4.</span> <span class="nav-text">arena如何释放pool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何管理arena-object"><span class="nav-number">6.</span> <span class="nav-text">如何管理arena_object</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-object所在的容器"><span class="nav-number">6.1.</span> <span class="nav-text">arena_object所在的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-object的创建和分配"><span class="nav-number">6.2.</span> <span class="nav-text">arena_object的创建和分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-object的释放"><span class="nav-number">6.3.</span> <span class="nav-text">arena_object的释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#usedpools是什么"><span class="nav-number">7.</span> <span class="nav-text">usedpools是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#usedpools的巧妙结构"><span class="nav-number">7.1.</span> <span class="nav-text">usedpools的巧妙结构</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">_huang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">59k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:53</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>


  <script src='https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.8.2/viz.js'></script>
  <script>
    String.prototype.chineseChar2englishChar = function chineseChar2englishChar(){
      // 将单引号‘’都转换成'，将双引号“”都转换成"
      var str = this.replace(/\’|\‘/g,"'").replace(/\“|\”/g,"\"");
      // 将中括号【】转换成[]，将大括号｛｝转换成{}
      str = str.replace(/\【/g,"[").replace(/\】/g,"]").replace(/\｛/g,"{").replace(/\｝/g,"}");
      // 将逗号，转换成,，将：转换成:
      str = str.replace(/，/g,",").replace(/：/g,":");
      str = str.replace(/《/g, "<").replace(/》/g, ">");
      return str;
    }

    String.prototype.htmldecode = function htmlDecode () {
       var ele = document.createElement('span');
       ele.appendChild(document.createTextNode(this));
       return ele.innerHTML;
    }

    let vizObjects = document.querySelectorAll('.graphviz')

    for (let item of vizObjects) {
      item.parentNode.style.textAlign = "center"
      let svg = undefined
      try {
        svg = Viz(item.textContent.chineseChar2englishChar(), 'svg')
      } catch(e) {
        svg = `<pre class="error">${item.textContent}</pre>`
      }
      item.outerHTML = svg
    }
  </script>


        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
